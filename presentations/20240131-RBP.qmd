---
title: "Best Practices in R"
author: "Adrian Zetner"
date: "2024-01-31"
logo: 20240131-RBP_images/thumbsupR.png
format: 
  revealjs:
    theme: [moon, rbp.scss]
    incremental: true
editor: source 
---

# ~~Best~~ Good Enough Practices in R {.title}

# Introduction

## Seminar Goals

-   What to take away from this seminar
    -   Ideas, resources, methods to improve future work
-   What not to take away from this seminar
    -   Any rush to apply these ideas retroactively to all previous projects
- Inspiration and content from sources listed at the end

::: notes
-   What to take away from this seminar
    -   Ideas, resources, methods to improve future work
-   What not to take away from this seminar
    -   Any rush to apply these ideas retroactively to all previous projects
    -   Do it while revisiting old projects if you have time and where appropriate

Inspiration and content from sources listed at the end: don't worry about too many notes

:::

## Table of Contents
1. Project Oriented Workflow
2. Readability
3. Reproducibility

# Project Oriented Workflow

::: notes
- A project-oriented workflow is an approach to work that centers around the organization, structure, and management of tasks within the context of a specific, self-contained project.
:::

## Why?

- Work on More Than One Thing at a Time
  
- Team Collaboration
  - Easier concurrent work
  - Easy distribution

- Start and Stop
  - Flexible work schedule
  - Regularly checkpoint the project to save progress

- Documentation for Continuity
  - Easy resumption 
  - Context and guidelines


::: notes
### Work on More Than One Thing at a Time
- If waiting for input, start another part of the project or another project independently (self-contained).
  
### Collaborate, Communicate, Distribute
- **Team Collaboration:**
  - Foster collaboration within a team by structuring the project to enable concurrent contributions.
  - Keeping projects self-contained facilitates easy distribution to team members and reporting.

### Start and Stop
- **Flexible Work Sessions:**
  - Embrace a flexible work schedule, allowing for starting and stopping based on availability and focus.
  - Regularly checkpoint the project to save progress.
- **Documentation for Continuity:**
  - Utilize thorough documentation for easy resumption and provide context and guidelines for others taking over or collaborating.
  - This includes future you!
:::

## How?

- Standardized organization of files *per project*
- Consistent actions

::: notes
- Dedicated directories with standardized organization of files *per project*
- Consistent action focused workflow
:::

# Organization of Project Directories üìÇ

## Organization of Project Directories üìÇ

- **Project Organization:**
  - Folder per project.
  - Top-level advertisement
    - RStudio/Git/{here} characteristic files

- **Path Construction with `here()`:**
  - Utilize `here()` function.
  - Paths relative to top-level.
  - [here package](https://cran.r-project.org/package=here).

::: notes
- Organize each logical project into a folder on your computer.
- Make sure the top-level folder advertises itself as such. This can be as simple as having an empty file named `.here`
- Or, if you use RStudio and/or Git, those both leave characteristic files behind that will get the job done.
- Use the `here()` function from the [here package](https://cran.r-project.org/package=here) to build the path when you read or write a file. 
	- Create paths relative to the top-level directory
:::


## \{here\} Package üìÇ

`here()` displays top-level folder location

```{r echo=TRUE}
library(here)
here()
```
::: {.footer}
[Source](https://github.com/jennybc/here_here)
:::

::: notes
* Criteria for top level
  * Is a file named `.here` present?
  * Is this an RStudio Project? Literally, can I find a file named something like `foo.Rproj`?
  * Is this an R package? Does it have a `DESCRIPTION` file?
  * Is this a checkout from a version control system? Does it have a directory named `.git` or `.svn`? 
:::

## \{here\} Package üìÇ

Build a path to something in a subdirectory and use it.

```{r echo=TRUE}
here("presentations", "20240131-RBP_images", "analysisworkflow.png")
here("presentations/20240131-RBP_images/")
arrow.file <- here("presentations/20240124-BWG_images/arrow_dataset.png")

file.info(arrow.file)["size"]
```


::: {.footer}
[Source](https://github.com/jennybc/here_here)
:::

::: notes
- This is taken directly from Jenny Bryan's github ode to the here package
- Now files within the project are easily accessible from a standardized format regardless of what file is calling
  - Rmd files look for subdirs under their location which if they're in a docs folder Data won't be
- Easily passable to another user / computer
- File locations can be more easily built programmatically
:::

## Folder Structure üìÇ

::: columns
::: {.column width="50%"}
![](https://intro2r.com/images/directory_structure.png){width="287"}
:::

::: {.column width="50%"}
- **Folder Structure:**
  - Data
  - Code
  - Documentation
  - External scripts
  - Outputs
- Start project from root
  - Console or IDE
  
:::
:::

::: notes
- Separate folders for data, code, documentation, external scripts, and outputs
- Use subdirectories for clarity and organization
- Start R from top-level.
  - Use {here} for paths.
  - Maintain top-level working directory.
  - Absolute paths at runtime.
:::

## RStudio Projects üìÇ

![](20240124-BWG_images/RStudio-Logo.png){fig-align="center" width="400"}

::: notes
- Teams Reactions to show who uses RStudio or not
:::


## RStudio Projects üìÇ

::: columns
::: {.column width="50%"}
- Settings stored in `<NAME>.Rproj`.

- **Open Project in RStudio:**
  - Dedicated R instance.
  - File browser points to Project directory.
  - Working directory set to Project.
:::

::: {.column width="50%"}
```
Version: 1.0
RestoreWorkspace: No
SaveWorkspace: No
AlwaysSaveHistory: Default
EnableCodeIndexing: Yes
UseSpacesForTab: Yes
NumSpacesForTab: 2
Encoding: UTF-8
RnwWeave: Sweave
LaTeX: pdfLaTeX
AutoAppendNewline: Yes
StripTrailingWhitespace: Yes
LineEndingConversion: Native
BuildType: Package
PackageUseDevtools: Yes
PackageInstallArgs: --no-multiarch --with-keep.source
PackageRoxygenize: rd,collate,namespace
```
:::
:::


::: notes
- RStudio leaves notes to itself in `<NAME>.Rproj`
- Open Project = dedicated instance of RStudio
    - Dedicated R process
    - File browser pointed at Project directory
    - Working directory set to Project directory
:::


# Consistent Actions üí•

::: notes
- Defining a clear and reproducible workflow for data analysis projects
:::

## {.center}

> Everything that matters should be achieved through saved code

::: notes
- All important objects or figures should be explicitly saved to file, via code
- Treat your workspaces like livestock, not pets
:::

## Save Source not the Workspace / Environment üí• 

- Livestock vs. Pets Analogy from Cloud Computing
  - Livestock: managed in herds, disposable.
  - Pets: unique, precious.

- Treat R processes like livestock.
  - Workspace disposability.
  - Non-reproducible workflows lead to heartache.

- Explicitly save important objects.
- Design away fear of reproducibility
- Checkpoints for long generation time objects

::: notes
- "Livestock is managed in herds and there is little fuss when individuals are lost or must be sacrificed. A pet, on the other hand, is unique and precious."
- cultivate a workflow in which you treat R processes (a.k.a. ‚Äúsessions‚Äù) like livestock. Any individual R process and the associated workspace is disposable
- if your workspace is a pet, i.e. it holds precious objects and you aren‚Äôt 100% sure you can reproduce them, you are guaranteeing heartache
- Use your code to explicitly save important intermediate objects so you know the environment is reproducible
- Long-generation time objects:
	- Isolate each computationally demanding step in its own script and write the precious object to file
	- Can simply reload the object from file while developing downstream scripts
- What's the best way to ensure you're not too precious about your workspaces?
:::

## Use a Blank Slate üí•

::: {.r-stack}
![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Wachstafel.jpg){.fragment fig-align="center" width="400" .fade-in-then-out}

![](20240131-RBP_images/blankslate.png){.fragment fig-align="center" width="400" .fade-in-then-out}

:::{.fragment}
`R --no-save --no-restore-data`
:::

:::

::: notes
- Wipe your workspace every load
- This can be set in RStudio global options
- or via command line
:::

## Restart R often üí•

::: {.r-stack}
![](20240131-RBP_images/restart.png){fig-align="center" width="400" .fragment .fade-in-then-out}

- Restart R to wipe environment
- Save code not workspaces
- Pressure to reinforce correct behaviours
  - Ensuring source code recreates important artefacts

:::

::: notes
- Saving code ‚Äì not workspaces ‚Äì is incredibly important because it is an absolute requirement for reproducibility. Renouncing .Rdata and restarting R often are not intrinsically important or morally superior behaviours. They are important because they provide constant pressure for you to do the right thing: save the source code needed to create all important artefacts of your analysis.
:::

# Analysis Project Workflow ‚ö°

## Use an IDE ‚ö°

![](20240131-RBP_images/rstudio.png){fig-align="center" width="600"}

::: notes
- Use an Integrated Development environment to smooth this workflow, I recommend RStudio
- RStudio, VSCode, VIM, whatever
- Take advantage of code-aware editor that will help you notice simple errors like typos and unclosed brackets as well as separate R processes per project
- An IDE offers many was to direct code to a running R process and encourages saving code in source files (R/Rmd)
- Use it to organize your workflow and guide towards best practices
- "Sometimes people resist the advice to use an IDE because it‚Äôs hard to incorporate into their current workflow and dismiss it as something ‚Äúfor experts only‚Äù. But this gets the direction of causality backwards: long-time and professional coders don‚Äôt do these things because they use an IDE. They use an IDE because it makes it so much easier to follow best practices." 
:::

## Software Management ‚ö°

- **Research Code and Software:**
  - Varied forms and sizes.
  - Includes code processing research data, scripts, and workflows.
  - Scriptable languages like R, Python, shell, etc
  - Standalone programs for specific research tasks.

::: notes
There are many different shapes and sizes of research software:
- Any code that runs in order to process your research data.
- A record of all the steps used to process your data (scripts and workflow such data analysis are software).
- Any scriptable language (R, Python, shell, etc.)
:::

## Software Management ‚ö°

::: {.r-stack}
- What can go wrong with research code?
  - What does code do?
  - Why did we do it this way?
  - No longer works
  - Accuracy at question

- Software projects range in size but all can benefit modular code:
  - Readable
  - Reusable
  - Testable
:::

::: notes
What can go wrong?
I don‚Äôt remember what this code does
I don‚Äôt remember why I made this choice
This code doesn‚Äôt work any more
I‚Äôm not sure if this calculation is correct

- Regardless of size, adopting a few Software Engineering practices can make your life much easier
- Focus on making code that is modular as it makes the code
  - Readable
  - Reusable
  - Testable
:::

## Software Management ‚ö°

::: {.r-stack}
![](20240131-RBP_images/teapot.jpg){.fragment fig-align="center" width="600" .fade-in-then-out}

:::{.fragment}
- Comment brief explanations

- Functions first
  - Clear inputs and outputs
  - Meaningful names
  - One main task

- Ruthlessly eliminate duplication
  - Functions
  - Data Structures
  - Work

:::

:::

::: notes
- A function is a reusable section of software that can be treated as a black box by the rest of the program. This is like the way we combine actions in everyday life. Suppose that it is teatime. You could get a teabag, put the teabag in a mug, boil the kettle, pour the boiling water into the mug, wait 3 minutes for the tea to brew, remove the teabag, and add milk if desired. It is much easier to think of this as a single function, ‚Äúmake a cup of tea‚Äù.
- When we're writing scripts built of functions we should think of it in much the same way and apply certain rules to each
- Give them a brief Description: Short is fine; always include at least one example of how the program is used. Remember, a good example is worth a thousand words: Where possible, the description should also indicate reasonable values for parameters, dependencies, etc
- Build programs out of short, single-purpose functions with:
  - clearly-defined inputs and outputs
  - meaningful names (applies to variables too), consider tab completion and name based on scope (counter can be i, major object should have a name that describes its purpose)
- Functions should have one main task, which can be combined into larger functions or workflows or if they get too complex, broken down again into single task functions
  - "Make a cup of Tea" shouldn't include "Take out the garbage" but it should contain smaller functions to "Boil Kettle" "prepare cup with teabag" etc
- Eliminate duplication:
- **Function Usage:**
  - Write and re-use functions.
  - Avoid copy-pasting code.
- **Data Structure Utilization:**
  - Use data structures like lists where possible over multiple related objects
  - Prefer creating a single structure (e.g., `score = (1, 2, 3)`) over multiple closely-related variables (e.g., `score1`, `score2`, `score3`).
- Work: **Library Exploration:**
  - Look for well-maintained libraries before writing your own 
  - Seek existing code for specific functions.
  - Explore language-specific library catalogs (e.g., CRAN for R, PyPI for Python).
  - Test libraries before relying on them.
:::


## Software Management ‚ö°

::: {.r-stack}
![](20240131-RBP_images/everything.jpg){.fragment fig-align="center" width="600" .fade-in-then-out}

![](20240131-RBP_images/analysisworkflow.png){.fragment fig-align="center" width="600" .fade-in-then-out}
:::

::: notes
- Split monolithic scripts into smaller, individual, independent portions
- Talk about image
:::

## Data Management üíΩ

- Why Data Management?
    - Data loss / corruption
    - Confusion about provenance
    - Version

::: notes
- Data loss / corruption: anything that makes it unusable
- Confusion about provenance: eg. source? purpose?
- Version: eg. what workflow generated the data?
:::

## Data Management üíΩ

- Data Management
    - Save the raw data.
    - Ensure raw data is backed up
    - Create analysis-friendly data.
	    - Create the data you wish to see in the world
	      - Self explanatory naming
	      - Open formats
	      - Machine readability
      - Export cleaned data that you wish you'd received
    - Record all the steps used to process data

::: notes
- Save data in its original form to ensure faithful retention for rerunning analyses, recovering from mishaps, and experimenting fearlessly. Consider making raw data read only and resist them temptation to overwrite with cleaned results
- For data that's impractical to manage this way, document the exact procedure, version details, and other pertinent information when working with large, stable databases.
- Back up raw data in multiple places: if it's not backed up it doesn't matter
- Analysis friendly data
  - Replace inscrutable variable and column names with self explanatory, machine-readable alternatives
  - Convert data from closed, proprietary formats to open, non-proprietary formats like CSV for tabular data, JSON, YAML, or XML for non-tabular data
  - Create an ideal dataset by focusing on improving machine and human readability without extensive filtering or adding external information. Prioritize machine readability for easy reuse
:::

## Data Management üíΩ

::: {.nonincremental}
![](20240131-RBP_images/tidy.png){.fragment fig-align="center" width="600"}
::: 


::: {.r-stack}

:::{.fragment .fade-in-then-out .nonincremental}

  - Each variable must have its own column.
  - Each observation must have its own row.
  - Each value must have its own cell.
  
:::
:::{.fragment .nonincremental}
  - Consistency
  - Vectorization
:::
:::


::: {.footer}
[Source](https://r4ds.had.co.nz/tidy-data.html)

:::

::: notes
- There are three interrelated rules which make a dataset tidy
- Why bother?
There‚Äôs a general advantage to picking one consistent way of storing data. If you have a consistent data structure, it‚Äôs easier to learn the tools that work with it because they have an underlying uniformity.

There‚Äôs a specific advantage to placing variables in columns because it allows R‚Äôs vectorised nature to shine. As you learned in mutate and summary functions, most built-in R functions work with vectors of values. That makes transforming tidy data feel particularly natural. 

- There are two main reasons to use other data structures:
  - Alternative representations may have substantial performance or space advantages.
  - Specialised fields have evolved their own conventions for storing data that may be quite different to the conventions of tidy data.

:::

## Data Management üíΩ

::: {.r-stack}
![](20240131-RBP_images/data.jpg){.fragment fig-align="center" width="600" .fade-out}

![](20240131-RBP_images/inputsandoutputs.png){.fragment fig-align="center" width="600"}
:::

::: notes
- In much the same way we don't want monolithic scripts, we also don't want data transformation to be an entire black box 
- Talk about image
  - Proprietary format to open machine readable
  - Interim scripts put out interim results to be reports
:::

# Readability üìë

::: notes
- Wasn't sure what to call this section as it covers a number of important topics and frankly this was the best I came up with
:::

## Naming Conventions üìë

- File names should be:
  - Machine readable
  - Human readable
  - Optional: Consistent
  - Optional: Play well with default ordering

::: notes
- File names should be:
  - Machine readable
  - Human readable
  - Optional: Consistent
  - Optional: Play well with default ordering
  
<!-- Made a fake list of filenames, created those files with `cat filenames.txt | xargs touch` -->
:::

## Machine Readable üìë

::: columns
::: {.column width="50%"}

- Regex/Globbing Friendly
  - Avoid spaces, punctuation, and accented characters
  - Maintain case sensitivity.

- Easy Computation
  - Use intentional delimiters for straightforward computational processes.
  - Deliberate delimiter use enhances computational efficiency.
    - Dashes for spaces between words
    - Underscores for chunks
:::

::: {.column width="50%"}
::: {.r-stack}
:::: {.fragment .fade-in-then-out}
```
20220120_patient-exposure_control.csv
20220120_patient-exposure_treatment.csv
20220215_patient-exposure_control.csv
20220215_patient-exposure_treatment.csv
20220215_patient-info_control.csv
20220310_patient-info_control.csv
20220520_patient-info_treatment.csv
20220805_patient-info_control.csv
20230120_patient-info_treatment.csv
20230215_patient-info_treatment.csv
20230310_patient-exposure_control.csv
20230310_patient-exposure_treatment.csv
20230405_patient-exposure_control.csv
20230405_patient-exposure_treatment.csv
20230405_patient-info_control.csv
20230615_patient-info_treatment.csv
20230710_patient-info_control.csv
20230710_patient-info_treatment.csv
20230805_patient-info_treatment.csv
```
::::

:::: {.fragment .fade-in-then-out}
```
‚ùØ ls -1 2022*
20220120_patient-exposure_control.csv
20220120_patient-exposure_treatment.csv
20220215_patient-exposure_control.csv
20220215_patient-exposure_treatment.csv
20220215_patient-info_control.csv
20220310_patient-info_control.csv
20220520_patient-info_treatment.csv
20220805_patient-info_control.csv
```
::::
:::: {.fragment .fade-in-then-out}
```
‚ùØ ls -1 *info*
20220215_patient-info_control.csv
20220310_patient-info_control.csv
20220520_patient-info_treatment.csv
20220805_patient-info_control.csv
20230120_patient-info_treatment.csv
20230215_patient-info_treatment.csv
20230405_patient-info_control.csv
20230615_patient-info_treatment.csv
20230710_patient-info_control.csv
20230710_patient-info_treatment.csv
20230805_patient-info_treatment.csv
```
::::
:::
:::

:::


::: notes
- **Regular Expression and Globbing Friendly:**
    - File names should be crafted to be easily processed using regular expressions and globbing (wildcard) patterns.
    - Consider avoiding spaces, punctuation, accented characters, and maintain case sensitivity for consistency in manipulation.
- **Easy to Compute On:**    
    - Intentionally use delimiters in file names, making them straightforward for computational processes.
    - Deliberate use of delimiters enhances the efficiency of computations.
:::

## Human Readable üìë

::: columns
::: {.column width="50%"}
- **Informative File Names:**
  - Include content information in file names.
  - Anticipate usage context for human understanding.

- **Slug:**
  - Implement slug concept for user-friendly and descriptive filenames.
  - 20230710_**patient-info_control**.csv
  
:::

::: {.column width="50%"}
::: {.r-stack}
:::: {.fragment .fade-in-then-out}
![](20240131-RBP_images/slug.jpg){fig-align="left" width="300"}
::::


:::: {.fragment .fade-in-then-out}
```{r echo=TRUE}
filedir <- here("presentations/20240131-RBP_images/fakedat/")
flist <- list.files(filedir, pattern = "info")

stringr::str_split_fixed(flist, "[_\\.]", 4)
```
::::

:::
:::
:::


::: notes
- **Informative Naming:**    
    - Ensure that the name of the file contains information about its content.
    - Anticipate the context in which the file will be used, facilitating human understanding.
- **Slug Concept:**    
    - Implement the concept of a slug in your filenames: creating user-friendly and descriptive URLs for better comprehension.
    - A slug is often defined as the part of a URL that identifies a page in human-readable keywords
- Easy parsing due to consistent use of delimiters
:::

## Easy Sorting üìë

- **Numeric Inclusion:**
  - Often for code
  - Include a numeric element for effective sorting
  - Left-pad with zeros for consistent width and visual sorting.
  - eg `01_import.R`

- **Dates:**
  - Utilize the ISO 8601 standard for date formatting: YYYYMMDD.
  - Ensures chronological sorting in file names by default.
  - eg `20220820_wedding-photos.zip`

::: notes
- **Numeric Inclusion:**    
    - Include something numeric in the file name for effective sorting of scripts.
    - Left-pad numeric elements with zeros to maintain a constant width for visually pleasing and consistent sorting.
- **ISO 8601 Standard for Dates:**    
    - Use the ISO 8601 standard for dates in file names to ensure chronological sorting by default.
- **Common-Sense Ordering:**    
    - Consider common-sense ordering based on the nature of the data or content.
    - Ensure that the file names sort logically for easier retrieval. 
:::

## Naming Conventions üìë

- Avoid:
  - Internal sequential numbers: `result1.csv`, `result2.csv`
  - Manuscript locations: `fig_3_a.png`


::: notes

- Avoid:
  - Sequential numbers: `result1.csv`, `result2.csv`
    - Difficult to parse, non-standard
  - Manuscript locations: `fig_3_a.png`
    - Liable to change 
:::

# Writing Meaningful Comments üí¨

## {.center}

> Programs must be written for people to read, and only incidentally for machines to execute.

## Meaningful Comments üí¨

**Rule 1: Comments should not duplicate the code**

## 

![](20240131-RBP_images/90pctcomments.webp){fig-align="center" width="500"}

## {#rule1 .center}

::: {.r-stack}

:::: {.fragment .fade-out}
```{r eval=FALSE, echo=TRUE}
#| code-line-numbers: false
if (x > 3) {
   ‚Ä¶
} # close if
```
:::: 
:::: {.fragment .fade-in-then-out}
```{r eval=FALSE, echo=TRUE}
#| code-line-numbers: false
i = i + 1 # Add one to i
```
::::
:::

::: notes
- Stack Overflow blog in resources with 10 rules, lets consider 3
	- Rule 1: Comments should not duplicate the code.
		- Training wheels carried over from early learning exercises
		- add visual clutter
		- waste time writing, reading, and updating for no gain
		- It adds no information whatsoever and incurs a maintenance cost.

:::

## Meaningful Comments üí¨

**Rule 2: Good comments do not excuse unclear code.**

## 

![](20240131-RBP_images/otherjokes.webp){fig-align="center" width="500"}


## {#rule2 .center}

::: {.r-stack}

:::: {.fragment .fade-in-then-out}
```{r eval=FALSE, echo=TRUE}
#| code-line-numbers: false
getBestChildNode <- function(node) {
  n <- NULL  # best child node candidate
  for (child_node in node$children) {
    # update n if the current state is better
    if (is.null(n) || utility(child_node) > utility(n)) {
      n <- child_node
    }
  }
  return(n)
}
```
:::: 
:::: {.fragment .fade-in-then-out}
```{r eval=FALSE, echo=TRUE}
#| code-line-numbers: false
getBestChildNode <- function(node) {
  bestNode <- NULL
  for (currentNode in node$children) {
    if (is.null(bestNode) || utility(currentNode) > utility(bestNode)) {
      bestNode <- currentNode
    }
  }
  return(bestNode)
}

```
::::
:::

::: notes
	- Rule 2: Good comments do not excuse unclear code.
		- For example generic variable names (x, y, etc) explained in comments
		- Need for comments is reduced if variables are named properly
:::

## Meaningful Comments üí¨

**Rule 3: If you can't write a clear comment, there may be a problem with the code.**

::: notes
- Rule 3: If you can't write a clear comment, there may be a problem with the code.
		- "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it." - Brian Kernighan
		- If you can't explain it simply, you don't understand it well enough
		- Rewrite the code to something you understand well enough to explain or, better yet, that is straightforward.
:::

## {.center}

> "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."

::: notes
  - Brian Kernighan
	- If you can't explain it simply, you don't understand it well enough
	- Rewrite the code to something you understand well enough to explain or, better yet, that is straightforward.
:::


## Roxygen2 Comments üí¨

![](20240131-RBP_images/roxygen2.png){fig-align="center" width="200"}

::: notes
Roxygen2 allows you to avoid the awful practice of documenting packages where you write .Rd files by hand.
:::

## Roxygen2 Comments üí¨

::: columns
::: {.column width="50%"}
- In-line documentation
- Rich, dynamic `.Rd` file generation
- Standard markdown

:::

::: {.column width="50%"}
:::: {.r-stack}
::::: {.fragment .fade-in-then-out}
```{r, echo=TRUE, eval=FALSE}
#| code-line-numbers: false

#' Add together two numbers
#' 
#' @param x A number.
#' @param y A number.
#' @returns A numeric vector.
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```
:::::
::::: {.fragment .fade-in-then-out}
```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add.R
\name{add}
\alias{add}
\title{Add together two numbers}
\usage{
add(x, y)
}
\arguments{
\item{x}{A number.}

\item{y}{A number.}
}
\value{
A numeric vector.
}
\description{
Add together two numbers
}
\examples{
add(1, 1)
add(10, 1)
}
```
:::::
::::
:::
:::

::: notes
There are a few advantages to using roxygen2 :
- Code and documentation are co-located. When you modify your code, it‚Äôs easy to remember to also update your documentation.
- roxygen2 provides a number of tools for sharing content across documentation topics and even between topics and vignettes.
- There‚Äôs a lot of `.Rd` boilerplate that‚Äôs automated away.
- You can use markdown, rather than having to learn a one-off markup language that only applies to `.Rd` files. In addition to formatting, the automatic hyperlinking functionality makes it much, much easier to create richly linked documentation.
:::

## Roxygen2 Comments üí¨

```{=html}
<iframe width="1000" height="500" src="https://thezetner.github.io/cct/index.html" title="Roxygen example"></iframe>
```

::: notes
- Allow for easy bundling of inline documentation into a website
:::


# Reproducibility üê£


## Modular and Reusable Code üê£

- Start programs/functions with explanatory comments.
- Use meaningful names for functions and variables.
- Explicitly state dependencies and requirements.
- Avoid commenting/uncommenting code sections for program control.
- Include a simple example or test data set for clarity.

::: notes
- As we've already discussed
- Writing functions and scripts for modularity
	- Place a brief explanatory comment at the start of every program or function
	- Give functions and variables meaningful names.
	- Make dependencies and requirements explicit.
	- Do not comment and uncomment sections of code to control a program's behavior.
	  - If it's going to be shared
	  - Use proper conditionals or remove
	- Provide a simple example or test data set.
- What is the ultimate version of this process?

:::

## Make an R Package üê£

- Why make an R package? 
  - Code Organization
  - Consistent documentation
  - Code Distribution
  - Dependency handling

::: notes
- Creating R packages for code reuse and distribution
Why make an R package? 
1. **Code Organization**: I am always trying to figure out where that ‚Äúfunction‚Äù I wrote months, weeks, or even days ago. Often times, I end up just re-writing it because it is faster than searching all my .R files. An R package would help in organizing where my functions go.
2. **Consistent documentation**: I can barely remember what half of my functions do let alone the inputs and outputs. An R package provides a great consistent documentation structure and actually encourages you to document your functions.
3. **Code Distribution**: No more emailing .R scripts! An R package gives an easy way to distribute your code for others. Especially if you put it on GitHub.
4. **Dependency handling**: No more failing scripts because library calls failed on load. Install the package and all of its dependencies are installed alongside it!

- Even if it's just for yourself
:::


## Make an R Package üê£


::: columns
::: {.column width="50%"}

- Package directory structure
  - Scripts in `R`
  - Documentation in `man`
  - README.md
  - DESCRIPTION, NAMESPACE
- {Roxygen2} for documentation
- {devtools} for process

:::

::: {.column width="50%"}
```
.
‚îú‚îÄ‚îÄ DESCRIPTION
‚îú‚îÄ‚îÄ NAMESPACE
‚îú‚îÄ‚îÄ R
‚îÇ   ‚îú‚îÄ‚îÄ cat_function.R
‚îÇ   ‚îú‚îÄ‚îÄ cat_images.R
‚îÇ   ‚îî‚îÄ‚îÄ cats-package.R
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ man
    ‚îú‚îÄ‚îÄ add_cat.Rd
    ‚îú‚îÄ‚îÄ cat_function.Rd
    ‚îú‚îÄ‚îÄ cats.Rd
    ‚îú‚îÄ‚îÄ get_cat.Rd
    ‚îî‚îÄ‚îÄ here_kitty.Rd
```

:::
:::

::: notes
- Making an R package involves creating a specific structure of directory and adding specific files
- Package directory structure
  - Scripts in `R`
  - Documentation in `man`
  - README.md
  - DESCRIPTION, NAMESPACE
- Easily accomplished with Roxygen2 and devtools
- This is the directory structure of the cats package linked in resources

:::

## Make an R Package üê£

::: columns
::: {.column width="50%"}

- DESCRIPTION file
  - Dependencies
  - Package metadata
  - Contact information

:::

::: {.column width="50%"}
```
Package: cats
Title: Cats
Version: 0.1
Author: Hilary Parker <hilary@etsy.com> [aut, cre]
Maintainer: Hilary Parker <hilary@etsy.com>
Authors@R: c( person("Hilary", "Parker", email = "hilary@etsy.com", role =
    c("aut", "cre")))
Description: Mew.
Depends:
    R (>= 3.0.2)
Imports:
    httr,
    ggplot2,
    jpeg
License: MIT
LazyData: true
Suggests:
    testthat
```

:::
:::

::: notes
- The job of the DESCRIPTION file is to store important metadata about your package. 
- Early on, use these metadata to record what packages are needed to run your package.
- Later, if released publicly let people get in touch with you over problems!
:::

## Make an R Package üê£

::: columns
::: {.column width="50%"}

- NAMESPACE file
  - Functions from your package
  - Imported functions from others

:::

::: {.column width="50%"}
```

# Generated by roxygen2 (4.0.1.99): do not edit by hand

export(add_cat)
export(cat_function)
export(get_cat)
export(here_kitty)
import(ggplot2)
import(httr)
import(jpeg)
```

:::
:::

::: notes
- The NAMESPACE file specifies which functions your package makes available for others to use and, optionally, imports functions from other packages.
:::

## Version Control üß≠

**Why version control in data analysis projects?**

::: columns
::: {.column width="50%"}
- **File Versioning**
- **Figure Recreation**
- **Code Modification Impact**
- **Directory Copying Fear**
- **Shared File Duplication**
- **Lost Data Files**
- **Analysis Selection Recover**
:::
::: {.column width="50%"}
- **Manuscript Collaboration Merge**
- **Accidental Deletion**
- **Project Location Recall**
- **Experiment Mistake Identification**
- **Directory Pollution**
- **Selective Changes**
- **Ad Infinitum**
:::
:::


::: notes
Many Reasons
:::


## Version Control üß≠

![](20240131-RBP_images/ew-versions.png){fig-align="center" width="500"}


## Version Control üß≠

- **What to Save:**
  - Human-created content.
  - Plain text files.
  - Avoid binary files.
  
::: notes
- What to save?
	- Back up (almost) everything created by a human being as soon as it is created
	- Optimized for plain text files (scripts) and can pinpoint changes between versions
	- Doesn't work well for binary files like PDFs or MS Office files
	- Raw data shouldn't change and intermediate files should be able to be reproduced by saved source so no need to change
:::

## Version Control: Manual üß≠
  
  **CHANGELOG.txt**
  
  ```
  ## 2016-04-08
  
  * Switched to cubic interpolation as default.
  * Moved question about family's TB history to end of questionnaire.
  
  ## 2016-04-06
  
  * Added option for cubic interpolation.
  * Removed question about staph exposure (can be inferred from blood test results).
  ```
::: notes
Add a file called `CHANGELOG.txt` to the project's
  `docs` subfolder and make dated notes about changes to the project in this file in reverse
  chronological order (i.e., most recent first). This file is the
  equivalent of a lab notebook, and should contain entries like those
  shown.
:::

## Version Control: Manual üß≠

  **Backup entire project folder**

  ```
  .
  |-- project_name
  |   -- current
  |       -- ...project content as described earlier...
  |   -- 2016-03-01
  |       -- ...content of 'current' on Mar 1, 2016
  |   -- 2016-02-19
  |       -- ...content of 'current' on Feb 19, 2016
  ```
  
::: {.fragment}
... please don't do this
:::
  
::: notes
Copy the entire project whenever a significant change has been made (i.e., one that
  materially affects the results), and store that copy in a sub-folder
  whose name reflects the date in the area that's being synchronized.
  This approach results in projects being organized as shown above
  
  
:::

## Version Control: VCS üß≠

- **Version Control System**
- **Efficient Backup Storage**
- **Automated Timestamps**
- **Automated Changelog and Accuracy**
- **Conflict Resolution and Merging**
- **Examples:** Git, SVN, Bitbucket, etc

::: notes
- VCS
- Much better than manual
- **Efficient Backup Storage:**
  - Version control eliminates the need for users to create backup copies of the entire project.
  - Safely stores sufficient information to recreate old versions of files on demand.

- **Automated Timestamps:**
  - Timestamps all saved changes automatically, eliminating the reliance on users to choose sensible names for backup copies.

- **Automated Changelog and Accuracy:**
  - Version control systems prompt users whenever a change is saved, ensuring a disciplined approach without relying on manual changelogs.
  - Maintains a 100% accurate record of actual changes made, valuable for troubleshooting later.

- **Conflict Resolution and Merging:**
  - Instead of blindly copying files to remote storage, version control checks for potential overwrites of others' work.
  - Facilitates conflict identification and merging changes, ensuring collaboration without loss of data.
  
- Links to very good tutorials in the resources section of this talk
:::

## Managing Project Dependencies üì¶

## {.center}

> The only way to be certain that code written by someone else will run on your machine and will produce the same results is to replicate their environment

::: notes
managing project dependencies is a significant issue
:::

## Managing Project Dependencies üì¶

- **What is the environment?**
	1. The version of the software used (eg. R 3.6.1 vs R 3.5.2) 
	2. The versions of the packages/extensions used (eg. ggplot2 3.3.0 vs ggplot2 2.2.0) 
	3. External software dependencies for packages (eg. pandoc)


::: notes
-  **What is the environment?**
	1. The version of the software used (eg. R 3.6.1 vs R 3.5.2) 
	2. The versions of the packages/extensions used (eg. ggplot2 3.3.0 vs ggplot2 2.2.0) 
	3. External software dependencies for packages (eg. pandoc)
- Challenges associated with package versions and dependencies in R projects
	- Often your code will run without any hiccups even when environments differ. Software engineers try to make sure your code will not stop working if you use a slightly different versions. 
	- But with all the software and all the dependencies eventually something will give and things will break. Even if the code runs successfully, there is a chance that the results could differ.
- Manually comparing environments is difficult to impossible, using containers to replicate another's computer is complex so we recommend a mid-point: ensuring package and R versions are the same each time the analysis is run
:::

## 

![](https://rstudio.github.io/renv/logo.svg){fig-align="center" width="500"}


# Resources

## http://tinyurl.com/COGseminar {.center}

![](20240131-RBP_images/qrcode_tinyurl.com.png)


## Seminar Content 

::: {.nonincremental}
- [What they forgot to teach you in R](https://rstats.wtf/)
- [Version Control with Git and Github](https://rstats-wtf.github.io/wtf-version-control-slides/)
- [Good Enough Practices in Scientific Computing - Paper](https://swcarpentry.github.io/good-enough-practices-in-scientific-computing/)
- [Good Enough Practices in Scientific Computing - Course](https://carpentries-lab.github.io/good-enough-practices/01-introduction.html)
- [The Turing Way](https://the-turing-way.netlify.app/index.html)
- [Project Oriented Workflow Slides](https://github.com/rstats-wtf/wtf-project-oriented-workflow-slides/blob/main/index.qmd)
- [My Previous R Course](https://github.com/TheZetner/intro-R-course)
- [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)
:::

## Moodle Cources 

::: {.nonincremental}
- [Introduction to Git](https://course.cscscience.ca/course/view.php?id=108)
- [Other R Courses](https://course.cscscience.ca/course/index.php?categoryid=23)
:::

## Readability

::: {.nonincremental}
- [Code Tells You How, Comments Tell You Why](https://blog.codinghorror.com/code-tells-you-how-comments-tell-you-why/)
- [Best practices for writing code comments](https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/)
- [Roxygen for in-line documentation](https://r-pkgs.org/man.html)
- [Quarto for reports](https://github.com/posit-conf-2023/quarto-r)
- [pkgdown to compile into websites](https://r-pkgs.org/website.html)
:::

## Reproducibility
### Packages

::: {.nonincremental}
- [R Packages](https://r-pkgs.org/)
- [Your first R package in 1 hour](https://www.pipinghotdata.com/posts/2020-10-25-your-first-r-package-in-1-hour/)
- [Writing an R package from scratch](https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/)
- [Making Your First R Package](https://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html)
:::

### Project Dependencies

::: {.nonincremental}
- [renv Documentation](https://rstudio.github.io/renv/articles/renv.html)
- [Reproducible R Toolbox](https://rpubs.com/glennwithtwons/reproducible-r-toolbox)
:::

## Useful Links

::: {.nonincremental}
- [Cheatsheets](https://posit.co/resources/cheatsheets/)
- [Hacker Laws](https://github.com/dwmkerr/hacker-laws)
- [Reproducible Reporting with R](https://noaa-iea.github.io/r3-train/)
:::































